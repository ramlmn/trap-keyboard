{"version":3,"sources":["../trap-keyboard.js"],"names":[],"mappings":"yXAAC,WAAW,CACV,aADU,iBAeR,aAAmC,iEAEjC,2BAA2B,CAArB,KAAQ,QAAd,CACE,MAAO,IAAI,UAAJ,CAAc,wBAAd,CAAP,CAGF,KAAK,KAAL,EANiC,CAQjC,KAAK,aAAL,CAAqB,IARY,CASjC,KAAK,YAAL,CAAoB,IATa,CAWjC,KAAK,UAAL,CAAkB,KAAK,UAAL,CAAgB,IAAhB,CAAqB,IAArB,CAXe,CAYjC,KAAK,WAAL,CAAmB,KAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAtB,CAZc,CAcjC,GAAM,GAAkB,OAAO,MAAP,IAAkB,CACxC,YADwC,CAExC,aAFwC,CAGxC,UAHwC,CAAlB,GAAxB,CAOA,KAAK,QAAL,CAAgB,GAAI,iBAAJ,CAAqB,KAAK,WAA1B,CArBiB,CAwBjC,KAAK,QAAL,CAAc,OAAd,CAAsB,KAAK,KAA3B,GAxBiC,CA4BjC,OAAO,gBAAP,CAAwB,QAAxB,CAAkC,KAAK,WAAvC,CA5BiC,CA+BjC,KAAK,WAAL,EACD,CA/CO,sEAiDM,CAEZ,GAAM,GAAW,MAAM,IAAN,CACf,KAAK,KAAL,CAAW,gBAAX,CAA4B,KAAK,WAAL,CAAiB,uBAA7C,CADe,CAAjB,CAKA,KAAK,aAAL,CAAqB,KAAK,oBAAL,GAPT,CASZ,KAAK,YAAL,CAAoB,KAAK,oBAAL,CAA0B,EAAS,OAAT,EAA1B,CACrB,CA3DO,oEA6DmB,CAEzB,MAAO,GAAK,IAAL,CAAU,WAAW,CAE1B,GAAM,GAAS,mBAAf,CAF0B,MAMD,MAAnB,KAAO,OAAT,EAAwD,QAAtB,KAAO,UAK9C,CAXM,CAYR,CA3EO,gDA6EU,OAEV,MAAK,aAAL,EAAsB,KAAK,YAFjB,MASM,CAAlB,KAAM,OATM,GAWV,EAAM,QAXI,CAYR,SAAS,aAAT,GAA2B,KAAK,aAZxB,GAcV,EAAM,cAAN,EAdU,CAeV,KAAK,YAAL,CAAkB,KAAlB,EAfU,EAmBR,SAAS,aAAT,GAA2B,KAAK,YAnBxB,GAqBV,EAAM,cAAN,EArBU,CAsBV,KAAK,aAAL,CAAmB,KAAnB,EAtBU,QAGd,GAAM,cAAN,EAuBH,CAvGO,mCA8GD,CAEL,KAAK,KAAL,CAAW,gBAAX,CAA4B,SAA5B,CAAuC,KAAK,UAA5C,CAFK,CAKD,KAAK,aALJ,CAMH,KAAK,aAAL,CAAmB,KAAnB,EANG,CAQH,KAAK,KAAL,CAAW,KAAX,EAEH,CAxHO,uCAgIC,CAEP,KAAK,KAAL,CAAW,mBAAX,CAA+B,SAA/B,CAA0C,KAAK,UAA/C,CACD,CAnIO,qDA6I6B,CAEnC,sNAcD,CA7JO,SAgKW,WAAjB,QAAO,OAAP,EAAgC,OAAO,OAhKjC,CAiKR,OAAO,OAAP,EAjKQ,CAkKmB,UAAlB,QAAO,OAAP,EAAgC,OAAO,GAlKxC,CAmKR,OAAO,cAAP,IAA2B,UAAW,CACpC,QACD,CAFD,CAnKQ,CAuKR,KAAK,YAAL,EAEH,CAzKA,G","file":"trap-keyboard.min.js","sourcesContent":["(function() {\n  'use strict';\n\n  /**\n   * A class which helps to trap user input inside an element\n   *\n   * @class TrapKeyboard\n   */\n  class TrapKeyboard {\n    /**\n     * Creates an instance of TrapKeyboard\n     * @param {Node} element\n     * @param {Object} [options={}]\n     * @memberof TrapKeyboard\n     */\n    constructor(element, options = {}) {\n      // Check if the element is a DOM node\n      if (!(element.nodeType === 1)) {\n        return new TypeError('Provide an ElementNode');\n      }\n\n      this._root = element;\n\n      this._firstTabStop = null;\n      this._lastTabStop = null;\n\n      this._onKeyDown = this._onKeyDown.bind(this);\n      this._onMutation = this._onMutation.bind(this);\n\n      const observerOptions = Object.assign({}, {\n        childList: true,\n        attributes: true,\n        subtree: true,\n      }, options);\n\n      // Add a MutationObserver to watch for DOM changes\n      this.observer = new MutationObserver(this._onMutation);\n\n      // Start the observer\n      this.observer.observe(this._root, observerOptions);\n\n      // Need to update on window resize if any CSS Media Queries might change\n      // the visibility and display of focusable elements\n      window.addEventListener('resize', this._onMutation);\n\n      // Initial setup\n      this._onMutation();\n    }\n\n    _onMutation() {\n      // Get all the possible elements that the user can interact with\n      const elements = Array.from(\n        this._root.querySelectorAll(this.constructor.focusableElementsString)\n      );\n\n      // Get the focusible element from top bottom\n      this._firstTabStop = this._getFocusibleElement(elements);\n      // Get the focusible element from bottom up\n      this._lastTabStop = this._getFocusibleElement(elements.reverse());\n    }\n\n    _getFocusibleElement(list) {\n      // Find a 'focusible' element\n      return list.find(element => {\n        // Get the computed styles of the element\n        const styles = getComputedStyle(element);\n\n        // Check if the element is accessible\n        // Not an ideal solution though\n        if (!(styles.display === 'none') || !(styles.visibility === 'hidden')) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n    }\n\n    _onKeyDown(event) {\n      // We need atleast two unique elements for it to work\n      if (!(this._firstTabStop && this._lastTabStop)) {\n        event.preventDefault();\n        return;\n      }\n\n      // If we are on the last element transfer the focus to first element and vice versa\n      // Check for TAB key press\n      if (event.keyCode === 9) {\n        // SHIFT + TAB\n        if (event.shiftKey) {\n          if (document.activeElement === this._firstTabStop) {\n            // Traverse back\n            event.preventDefault();\n            this._lastTabStop.focus();\n          }\n        } else {\n          // TAB\n          if (document.activeElement === this._lastTabStop) {\n            // Traverse forward\n            event.preventDefault();\n            this._firstTabStop.focus();\n          }\n        }\n      }\n    }\n\n    /**\n     * Trap the users keyboard, this effects until unTrap is called\n     *\n     * @memberof TrapKeyboard\n     */\n    trap() {\n      // Add a keydown event\n      this._root.addEventListener('keydown', this._onKeyDown);\n\n      // Focus the first element, if any\n      if (this._firstTabStop) {\n        this._firstTabStop.focus();\n      } else {\n        this._root.focus();\n      }\n    }\n\n\n    /**\n     * Stop trapping the users keyboard\n     *\n     * @memberof TrapKeyboard\n     */\n    unTrap() {\n      // Remove the event listeners\n      this._root.removeEventListener('keydown', this._onKeyDown);\n    }\n\n\n    /**\n     * CSS query string for possbile focusible elements\n     *\n     * @readonly\n     * @static\n     * @memberof TrapKeyboard\n     */\n    static get focusableElementsString() {\n      // All possible focusable elements\n      return [\n        'a[href]',\n        'area[href]',\n        'button:not([disabled])',\n        'input:not([disabled])',\n        'select:not([disabled])',\n        'textarea:not([disabled])',\n        'datalist:not([disabled])',\n        'iframe',\n        'object',\n        'embed',\n        '[tabindex]:not([tabindex=\"-1\"])',\n        '[contenteditable]',\n      ].join();\n    }\n  }\n\n  if (typeof module != 'undefined' && module.exports) {\n    module.exports = TrapKeyboard;\n  } else if (typeof define === 'function' && define.amd) {\n    define('TrapKeyboard', [], function() {\n      return TrapKeyboard;\n    });\n  } else {\n    self.TrapKeyboard = TrapKeyboard;\n  }\n}());\n"]}